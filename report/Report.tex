\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=2.5cm]{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{xcolor}

\definecolor{lightblue}{RGB}{173, 216, 230}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=blue,
}

\begin{document}

\pagenumbering{gobble}

\begin{center}            
    {\LARGE\textbf{COS314 Assignment Three}}\\
    
    \vspace{4cm}
    
    {\Large\textbf{Aplication of Machine Learning Alogorithms to Stock Trading Prediction}}\\
    \vspace{0.5cm}
    {\large\textbf{Using GP, MLP and Decision Trees}}\\
    
    \vspace{12cm}

    {\large Team:}\\
    \vspace{0.3cm}
    {\large Tinotenda Chirozvi (22547747)}\\
    {\large Lubabalo Tshikila (22644106)}\\
    {\large Dean Ramsay (22599012)}\\
    
    \vspace{2cm}
    
    {\large\textbf{Due Date: 24 May 2025}}\\
    
\end{center}

\clearpage
\pagenumbering{arabic}

\section*{Abstract}
This report presents the design, implementation, and evaluation of three machine learning algorithms for the classification of stock market movements. In particular the movement of the bitcoin value to predict whether it will rise(buy) or fall (sell). The three algorithms used: Genetic Programming Algorithm (GP), Decision Tree Algorithm (DT) and a Multi-Layer-Perceptron Algorithm (MLP).

\section{Introduction}
Data of historic BTC stock movements were provided, already divided into training and test data as BTC\_train.csv and BTC\_test.csv respectively.
The training data was used to train the three models which were then evaluated using the test data to verify their performance.


\section{Machine Learning Algorithms}

\subsection{Genetic Programming Algorithm}
The balance of pheromone influence is critical: if values accumulate too rapidly, the algorithm risks becoming trapped in local optima as ants repeatedly choose the same paths rather than exploring alternatives. Conversely, if pheromone values are too subtle, their effect becomes negligible, and the search degenerates into a random exploration. In our implementation, the influence of the pheromone is controlled by the parameter $\alpha = 1.0$ in the probability calculation, while the heuristic information (score-to-distance ratio) is weighted by $\beta = 3.0$.

\subsection{Multi-Layer-Perceptron Algorithm}
Route construction begins at the start node and proceeds iteratively. At each step, the algorithm identifies \textit{viable nodes} - those unvisited nodes that can be reached and still allow the vehicle to return to the end node without exceeding $t_{max}$. This feasibility check is calculated as:

\begin{equation}
d_{current,node} + d_{node,end} + d_{current} \leq t_{max}
\end{equation}

where $d_{current,node}$ is the distance from the current node to the candidate node, $d_{node,end}$ is the distance from the candidate to the end node, and $d_{current}$ is the total distance traveled so far.

From this feasible set, the next node is selected probabilistically using a formula that balances exploitation (following strong pheromone trails) with exploration (considering potential rewards). The probability of selecting node $j$ when at node $i$ is given by:

\begin{equation}
p_{ij} = \frac{\tau_{ij}^{\alpha} \cdot \eta_{ij}^{\beta} + r}{\sum_{l \in \text{viable}} (\tau_{il}^{\alpha} \cdot \eta_{il}^{\beta} + r)}
\end{equation}

where:
\begin{itemize}
\item $\tau_{ij}$ is the pheromone level on edge $(i,j)$
\item $\eta_{ij} = \frac{\text{score}_j}{d_{ij}}$ is the heuristic information (score-to-distance ratio)
\item $\alpha$ (pP = 1.0) and $\beta$ (hP = 2.0) are parameters controlling the relative influence of pheromone versus heuristic
\item $r$ is a small random factor (0.1) added to encourage exploration
\end{itemize}

\subsection{Decision Tree Algorithm}
The three main constraints used in the ACO algorithm are:
\begin{itemize}
\item Each vehicles route must not exceed tim/distance limit ($t_{max}$)
\end{itemize}
To solve this we simply have to check what a vehicles current distance/time value is before select a next node and then check whether this value plus the time taken to reach the candidate node and get back to the end node is less than its ($t_{max}$) value. As shown in algorithm (1).

\begin{itemize}
\item Each node can be visited visited by only 1 vehicle
\end{itemize}
For this constraint, we maintain a list of nodes ($unvitednodes$) which stores all the nodes that have not yet been visited. After the construction of each route we update this list by removing the nodes that were used in the vehicles route construction.

\begin{itemize}
\item All vehicles must begin at the indicated start node and finish at the end node.
\end{itemize}
All vehicles have a ($path$) vector attribute which is initialized to contain the value 0 at the start. The route is then constructed from this point until, there are no viable option for the node to move to. When this is the case, the node is forced to return to the end node. It is guaranteed to reach the end node due to the check made in algorithm (1).

\section{Results}

% Summary table of all datasets
\begin{table}[htbp]
\centering
\caption{Summary of ACO Results Across All Datasets}
\label{tab:summary}
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\textbf{Dataset} & \textbf{Nodes} & \textbf{Vehicles} & \textbf{Max Moves} & \textbf{Best Iter} & \textbf{Total Score} & \textbf{Total Dist} \\
\hline
p3.2.a.txt & 33 & 2 & 7.5 & i0 & 90 & 13.11 \\
\hline
p3.2.c.txt & 33 & 2 & 12.5 & i2 & 160 & 24.10 \\
\hline
p3.3.a.txt & 33 & 3 & 5.0 & i0 & 30 & 7.83 \\
\hline
p3.3.c.txt & 33 & 3 & 8.3 & i0 & 120 & 22.84 \\
\hline
p3.4.s.txt & 33 & 4 & 26.2 & i2 & 520 & 101.29 \\
\hline
p3.4.t.txt & 33 & 4 & 27.5 & i0 & 490 & 107.30 \\
\hline
p7.2.a.txt & 102 & 2 & 10.0 & i0 & 30 & 18.94 \\
\hline
p7.2.m.txt & 102 & 2 & 130.0 & i4 & 477 & 251.82 \\
\hline
p7.3.h.txt & 102 & 3 & 53.3 & i2 & 318 & 158.52 \\
\hline
p7.4.g.txt & 102 & 4 & 35.0 & i3 & 190 & 135.91 \\
\hline
p7.4.q.txt & 102 & 4 & 85.0 & i2 & 540 & 332.15 \\
\hline
\end{tabular}
\end{table}

\clearpage
\section{Analysis}

Several key observations can be made from the results of the ACO above.

\subsection{Problem Size Affect}

The ACO algorithm seemed to find and maintain solutions to smaller problems such as those with 33 nodes quickly but failed to improve on them. Perhaps more exploration may be needed.

\subsection{Impact of Vehicle Count and Time Constraints}

\begin{itemize}
    \item When more vehicles are available (e.g., p3.4.s.txt with 4 vehicles), the algorithm achieves higher scores compared to instances with fewer vehicles (e.g., p3.2.a.txt with 2 vehicles).
    \item Increasing ($t_{max}$) leads to higher scores, as vehicles can visit more high score nodes. Compare p3.2.a.txt ($t_{max}=7.5$, score=90) with p3.2.c.txt ($t_{max}=12.5$, score=160).
\end{itemize}

\subsection{Potential Improvements}

To address the limited improvement observed in some instances, several modifications could be made:

\begin{itemize}
    \item \textbf{Dynamic Parameter Adjustment}: Adapting parameters during the run based on convergence behavior could help escape local optima.
    
    \item \textbf{Min-Max Pheromone Limits}: Implementing upper and lower bounds on pheromone values might prevent premature convergence.
    
    \item \textbf{Solution Diversity Mechanisms}: Introducing mechanisms to maintain diversity in the population, such as different pheromone matrices for subsets of ants or occasional random restarts.
    
    \item \textbf{Local Search}: Incorporating local search procedures to refine solutions could improve the quality of results, especially when the ACO reaches a plateau.
\end{itemize}

Overall, the ACO algorithm has demonstrated it was effective in solving the TOP across various datasets, particularly in larger, more complex instances.

\end{document}